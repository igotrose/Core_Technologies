# 第四章  操作符和表达式
## 操作符
### 算术操作符
```
+ - * / %
```
除了`%`操作符，其余操作符都适用于浮点类型和整数类型
### 移位操作符
1. `<<`  左移操作符(左移n位相当于乘以2的n次方)  
    左边丢弃，右边补零
    ```
    示例：109 << 3 = 104
    移位前          01101101
    移位中       01101101
    移位后          01101000
    ```
2. `>>`  右移操作符(右移n位相当于除以2的n次方)
    - 逻辑移位：右边丢弃，左边补零
        ```
        示例：150 >> 2 = 37               
        移位前          10010110
        移位中            10010110
        移位后          00100101
        ``` 
    - 算术移位：右边丢弃，左边补符号位
        ```
        示例：150 >> 2 = 229              
        移位前          10010110
        移位中            10010110
        移位后          11100101
        ``` 
**避免移动负号位**
### 位操作符
1. `&` 按位与，运算规则：有零为零，两一为一 
2. `|` 按位或，运算规则：有一为一，两零为零
3. `^` 按位异或，运算规则：相同为零。相异为一
4. `~` 按位取反，将操作数中原有1的位，变0。反之！ 
#### 位的操纵
- 把指定位设置为1
    ```c
    value |= 1 << bit;
    ```
- 把指定位设置为0 
    ```c
    value &= ~(1 << bit);
    ```
### 赋值
- 复合赋值符
    ```
    += -= *= /= %= &= |= ^= <<= >>=    
    ```
### 单目操作符
1. `!` 逻辑非，如果操作数为假，结果为真。反之！
2. `~` 按位取反，将操作数中原有1的位，变0。反之！
3. `-` 负号   
4. `+` 正号
5. `&` 取地址，取地址，将地址赋予指针变量
6. `*` 间接访问，和指针一起使用
7. `sizeof` 判断操作数的类型长度
8. `(类型)` 强制类型转换
9. `++` 增值
10. `--` 减值
### 关系操作符
```
> >= < <= != ==
```
### 逻辑操作符
### 条件操作符（三目操作符）
```c 
expression1 ? expression2 : expression3
```
如果`expression1`成立，执行`expression2`，否则执行`expression3`
### 逗号操作符
```c
    expression1,expression2,...,expressionN
```
整个表达式的值为最后一个表达式的值。
### 下标引用、函数调用和结构成员
1. `[]`  下标引用
2. `()`  函数调用
3. `.`  访问结构成员
4. `->`  访问结构成员
## 布尔值
零为假，非零为真
## 左值和右值
    左值就是那些赋值操作符左边的东西
    右值就是那些赋值操作符右边的东西
    左右值并不是都可以随意互换
## 表达式求值
### 隐式类型转换（可以理解为编译器悄悄进行的操作）
    整型提升：
    将短整型和字符型转换为普通整型（将原码进行截断）
### 算术转换
    算术运算符的操作数必须是相同类型或可以进行算术转换的类型
### 操作符的属性
操作符的优先级、操作符的结合性以及操作符是否控制执行的顺序这三个因素决定了表达式的求值顺序
### 优先级和求值的顺序
写代码时，只写存在一种思路的代码
## 总结
### 警告的总结
1. 有符号值的右移位操作是不可移植的
2. 移位操作的位数是个负值
3. 连续赋值中各个变量的长度不一
4. 误用`=`和`==`进行比较
5. 误用`&`和`&&`进行逻辑与
6. 误用`|`和`||`进行逻辑或
7. 在不同的用于表示布尔值的非零值之间进行比较
8. 表达式赋值的位置并不决定表达式计算的精度
### 编程提示的总结
1. 使用复合赋值符可以是程序更加简洁
2. 使用条件操作符代替`if-else`语句可以提高程序的可读性
3. 使用逗号操作符来消除多余的代码
4. 不要混淆整形和布尔值
## 问题
![Alt text](question_5_8_1.png)
![Alt text](question_5_8_2.png)
![Alt text](question_5_8_3.png)
![Alt text](question_5_8_4.png)  
![Alt text](question_5_8_5.png)
 
1. 表达式的类型是float，值是2.0。
2. 没有固定答案，看编译器吧，可能是-10、-2或者-5。
3. 操作硬件寄存器
4. 差不多的吧。
5. 见代码
```c
// 判断闰平年
#include<stdio.h>
int main()
{
    int year, leap_year;
    scanf("%d\n", &year);
    if( (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 )
    {
        leap_year = 1;
    }
    else
    {
        leap_year = 0;
    }
    return 0;
}
```
6. 偷个懒，GPT一下，没想到这么多。
    ![Alt text](question_5_8_answer_1.png)
7. In range。首先1 <= a 成立，可以当作1，再者1 <= 20,条件成立进入if。
8. hahaha!!!!
    [Alt text](question_5_8_answer_2.png)
9. 不能，for循环后不清楚non_zero的值。
10. 再偷个懒哈哈哈！
    [Alt text](question_5_8_answer_3.png)
11. 参考答案!
    [Alt text](question_5_8_answer_4.png)
12. 声明一个负数，进行右移操作，对其进行原反补的计算，再运行输出这个结果就知道了。

