# 数据
## 基本数据类型
C语言中，由4种基本数据类型组成：整型、浮点型、指针型和聚合类型。
### 整型家族
整型家族包括字符型、短整型、整型、长整型，都有符号和无符号两种。整型家族在内存中以补码的形式存储，输出的是原码形式
|类型|范围|
|----|----|
|char| -128~127 或 0~255|
|short| -32768~32767|
|int| -2147483648~2147483647|
|long| -2^31 ~ 2^31-1|
|unsigned char| 0~255|
|unsigned short| 0~65535|
|unsigned int| 0~4294967295|
|unsigned long| 0~2^32-1|

这里需要注意不同类型变量的范围是不一样的，变量做类型转换的时候，需要注意数据溢出。
1. 整型字面值常量：可以用十进制、八进制、十六进制表示，前缀可以是`0x`或`0`表示十六进制，也可以省略前缀表示八进制。
2. 枚举类型：可以定义一组整型常量，每个常量的值都是从0开始递增的。
### 浮点类型
C语言中，浮点类型有两种：单精度浮点型和双精度浮点型。
|类型|大小|精度|
|----|----|----|
|float| 4字节| 7位有效数字|
|double| 8字节| 15位有效数字|

浮点型变量的字面值常量可以用十进制、科学计数法表示，也可以用`f`或`l`后缀表示单精度或双精度浮点型。
### 指针
指针可以有效地操作内存中的数据，指针变量的值是存储在内存中的地址，可以用来存放地址、数组名、函数名等。
1. 指针常量
2. 字符串常量
## 基本声明
变量声明的基本形式
```
说明符 声明表达式列表
```
- 说明符：变量类型、存储类别、函数返回类型等。
- 声明表达式列表：变量名、数组下标、函数参数列表等。
### 初始化
在一个声明语句中，可以对变量进行初始化，初始化的形式有两种：
1. 直接初始化：在变量名后面加等号和初始值，如`int a = 10;`。
2. 间接初始化：在声明语句中，对变量的地址赋值，如`int *p = &a;`。
### 声明简单数组
为了声明一个数组，需要指定数组的元素个数和元素类型。如`int a[10];`声明了一个10个整数的数组。数组的下标总是从0开始，可以用变量表示下标，如`a[i]`表示数组`a`的第`i`个元素。使用数组一定要注意数组越界的问题
### 声明指针
指针变量声明的形式为`类型 *变量名`，如`int *p;`声明了一个整型指针变量`p`。指针变量可以用来存放地址、数组名、函数名等。指针变量的初始化有两种形式：
1. 直接初始化：在指针变量名后面加等号和地址值，如`int *p = &a;`。
2. 间接初始化：在声明语句中，对指针变量的地址赋值，如`int **pp = &p;`。
### 隐式声明
函数如果不显示声明返回值类型，则默认返回int类型。如果不显示声明参数类型，则默认参数类型为int。
## `typedef`
`typedef`关键字可以给已有类型定义新的名称，如`typedef int INT;`。这样可以简化代码，提高可读性。
## 常量
常量是指不能被修改的变量，在程序运行时，其值不能被改变。常量的声明形式为`const 类型 变量名 = 值;`。常量可以用来表示一些固定值，如圆周率`PI = 3.14159265358979323846;`。常量的作用主要是提高程序的可读性和可维护性。
## 作用域
当变量在程序的某个部分被声明时，只有在有在程序的一定区域内才能被访问，
### 代码块作用域
位于花括号`{}`中的代码块，称为代码块作用域。
### 文件作用域
任何位于源文件中的变量、函数、类型等，都具有文件作用域，他表示这些变量、函数、类型在整个源文件中都有效。
### 原型作用域
只适用于函数声明，表示函数的原型，在函数定义之前有效。
### 函数作用域
只适用于函数内部，表示函数内的变量、函数、类型等的作用域。
## 链接属性
标识符的连接属性决定了标识符的作用域、存储类型、生命周期等。链接属性一共有以下几种：
- 外部链接：全局变量、函数、静态变量、静态函数。
- 内部链接：局部变量、函数。
- 无链接：未定义的变量、函数。

使用`extern`关键字可以声明外部变量、函数。`static`关键字可以声明内部变量、函数。
## 存储类型
变量的存储类型决定了变量在内存中的布局，有以下几种存储类型：
- 静态存储类型：静态变量在程序运行前分配内存，在程序运行后一直存在，直到程序结束。
- 自动存储类型：自动变量在程序块执行时分配内存，在程序块执行结束时释放内存。
- 动态存储类型：动态变量在程序运行时分配内存，程序运行结束后释放内存。
- 寄存器存储类型：寄存器变量在程序运行时分配内存，程序运行结束后释放内存。
## 初始化
变量的初始化，函数的创建都需要开销，因此初始化的次数应该尽量减少。
## `static`关键字
- 当他用于函数声明时，表示函数的原型，在函数定义之前有效，且不能被其他文件调用。
- 当他用于变量定义时，表示静态变量，在程序运行前分配内存，在程序运行后一直存在，直到程序结束。

## 警告的总结
1. 在声明指针变量时采用容易误导的写法
2. 误解指针声明中初始化的含义
## 编程提示的总结
1. 为了保证最佳的可以执行，把字符的值限制在有符号和无符号字符范围交集范围之内，或者不要再字符上执行算术运算
2. 不要把整型值和枚举值混在一块使用
3. 不要依赖隐式声明
4. 再定义类型的新名字时，使用`typedef`而不是`#define`
5. 用`const`声明其值不会修改的变量
6. 使用名字常量而不是字面值常量
7. 不要再嵌套的代码块之间使用相同的变量名
8. 除了实习的具体定义位置外，在它的其他声明位置都是用`extern`关键字声明变量、函数、类型
## 问题
![Alt text](question_3_13_1.png)
![Alt text](question_3_13_2.png)
![Alt text](question_3_13_3.png)
![Alt text](question_3_13_4.png)
![Alt text](question_3_13_5.png)
1. 可以通过以下代码验证
    ```c
    #include<stdio.h>
    #include<limits.h>
    int main()
    {   
        printf("%d ~ ", SCHAR_MIN);
        printf("%d\n", SCHAR_MAX);
        printf("%d\n", UCHAR_MAX);
        printf("");

        printf("%d ~ ", SHRT_MIN);
        printf("%d\n", SHRT_MAX);
        printf("%d\n", USHRT_MAX);
        printf("");

        printf("%d ~ ", INT_MIN);
        printf("%d\n", INT_MAX);
        printf("%d\n", UINT_MAX);
        printf("");

        printf("%d ~ ", LONG_MIN);
        printf("%d\n", LONG_MAX);
        printf("%d\n", ULONG_MAX);
        printf("");
        
        return 0;
    }
    ```
2. 可以通过以下代码验证
    ```c
    #include<stdio.h>
    #include<float.h>
    int main()
    {
        printf("%f ~ ", FLT_MIN);
        printf("%f\n", FLT_MAX);
        printf("\n");

        printf("%lf ~ ", DBL_MIN);
        printf("%lf\n", DBL_MAX);
        printf("\n");

        printf("%llf ~ ", LDBL_MIN);
        printf("%llf\n", LDBL_MAX);
        printf("\n");
        return 0;
    }
    ```
3. 使用变量类型一定要有一个确定的长度，对于希望成为缺省长度的整数，根据其能够容纳的最大值进行别名，并在每台机器创建一个头文件，用`typedef`进行声明。  
4. 编译程序时会发生警告。可能会导致数据截断或者溢出，不同编译器的运行结果不一样。  
5. 编译程序时会发生警告。会导致精度丢失。  
6. `enum { PENNY, NICKEL, YUAN, DOLLAR, POUNDS};`  
7. 因为输出的格式符是`%s`，且传入的是枚举常量，应该用`%d`或者`%u`接收，所以不能确定输出什么。  
8. 不允许。
9. 显示地标记整数类型为有符号类型，并增加代码的可读性和明确性，从而提高代码的可以执行的和理解性。
10. 否，一个有符号值和无符号值仅有的区别是在于他的一半值是如何解释的。  
11. `float`类型所能容纳的值精度比`int`类型要小。  
12. 没有不同。
13. 左边可以，右边不行。不能给常量赋值。
14. 错，只能在该声明后到该代码块结束部分访问。
15. 错，局部变量永远不能被直接访问。
16. 不会发生变化，`static`关键字并不能修改变量的作用域。
17. 这是全局变量，不需要添加额外的声明。
18. 不会，依然是全局变量。同一文件下都可以访问。
19. 因为是不同文件访问变量，所以要添加额外的声明。将`int x`;修改为`extern int x`;
20. 若用`static`去修饰声明，则任何外部文件都不能访问本文件的变量。
21. 可能相同。  
22. 若出现在代码内部，该变量的值在每次执行代码块时都会被重新初始化；若在代码块外，则可能只用声明一次，具体看情况。  
23. 略
24. 略
